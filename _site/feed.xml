<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>ZP</title>
		<description>ZP's blog</description>		
		<link>http://zp.rensidiaochaotian.com/</link>
		<atom:link href="http://zp.rensidiaochaotian.com//feed.xml" rel="self" type="application/rss+xml" />
		
			<item>
				<title>非对称加密算法RSA和应用IV - GnuPG</title>
				<description>&lt;p&gt;GnuPG(GNU Privacy Guard, GPG)是一种加密软件，是&lt;a href=&quot;http://zh.wikipedia.org/wiki/PGP&quot; title=&quot;PGP&quot;&gt;PGP(Pretty Good Privacy)&lt;/a&gt;满足GPL协议的替代物，用于加密、数字签名及产生非对称密钥。GnuPG依照OpenPGP(IETF)技术标准设计。由于GPG2.0使用的新软件架构不支持某些用途，因此GPG存在两个分支版本1.x与2.0&lt;/p&gt;

&lt;h1&gt;准备&lt;/h1&gt;

&lt;h2&gt;生成密钥&lt;/h2&gt;

&lt;p&gt;生成密钥操作简单，只需按照提示一步步选择&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --gen-key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;提示选择密钥种类，其中选项1默认，加密和签名都使用RSA；选项2使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Digital_Signature_Algorithm&quot; title=&quot;Digital Signature Algorithm&quot;&gt;DSA&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/ElGamal_encryption&quot; title=&quot;ElGamal encryption&quot;&gt;Elgamal&lt;/a&gt;；选项3和4仅生成签名&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;Please select what kind of key you want:
   (1) RSA and RSA (default)
   (2) DSA and Elgamal
   (3) DSA (sign only)
   (4) RSA (sign only)
Your selection?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接回车选择默认，之后提示选择RSA密钥长度，默认2048位&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;RSA keys may be between 1024 and 4096 bits long.
What keysize do you want? (2048)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之前提到1024位密钥在768位被破解后已受到威胁，而过长密钥需要更长的加解密时间，根据需要选择。直接回车，接着需选择密钥有效期&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;Please specify how long the key should be valid.
         0 = key does not expire
      &amp;lt;n&amp;gt;  = key expires in n days
      &amp;lt;n&amp;gt;w = key expires in n weeks
      &amp;lt;n&amp;gt;m = key expires in n months
      &amp;lt;n&amp;gt;y = key expires in n years
Key is valid for? (0)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认无过期时限，如果无法保证私钥安全，可选择过期时限。输入数字，可跟随w m y设置密钥有效的天数、周、月或年。输入错了？别担心，回车后还有确认的步骤&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;Key expires at 2014年07月05日 星期六 17时01分08秒 CST
Is this correct? (y/N)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;直接回车修改有效期，或输入y之后回车确认。接着需填写个人信息，用于辨认密钥所有者(签名)。需输入真实姓名，邮箱地址和注释&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;GnuPG needs to construct a user ID to identify your key.

Real name: Your Name
Email address: youremail@example.com
Comment: Tutorial key
You selected this USER-ID:
    &amp;quot;Your Name (Tutorial key) &amp;lt;youremail@example.com&amp;gt;&amp;quot;

Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit?
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结束后提示是否需修改信息，输入O确认。之后立即会跳出一个对话框要求输入用于保护私钥的密码，称为&lt;strong&gt;通行句&lt;/strong&gt;。通行句使用户可以使用与此密钥有关的各项功能。输入结束后系统开始生成密钥，过程中需生成一些随机数，要求做一些随机动作提高系统随机数的自由度，保证每个密钥都不相同。一段时间后，生成密钥过程完成，返回一些信息，如&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg: ${HOME}/.gnupg/trustdb.gpg: trustdb created
gpg: key 35D7ED67 marked as ultimately trusted
public and secret key created and signed.

gpg: checking the trustdb
gpg: 3 marginal(s) needed, 1 complete(s) needed, PGP trust model
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u
pub   2048R/35D7ED67 2014-06-30
      Key fingerprint = 62F1 855C 6C03 6D67 0D8F  9FB1 7A2B 8CED 35D7 ED67
uid                  Yichen Zhao (First) &amp;lt;zebrap25@gmail.com&amp;gt;
sub   2048R/53055D3E 2014-06-30
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中35D7ED67是公钥签名(uid)的哈希值，可用于替代uid来辨认公钥。为方便使用，添加环境变量&lt;code&gt;export GPGKEY=35D7ED67&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;生成取消密钥证书&lt;/h2&gt;

&lt;p&gt;作废公钥时需使用取消密钥证书。建议在生成密钥同时制作取消密钥证书，并将取消密钥证书安全存放。使用时无需通行句即可作废公钥，方便，但泄漏后任何人都可将你的公钥作废&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --output revoke.txt --gen-revoke $GPGKEY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要使用以上命令，必须已存在公钥。整个过程也有向导，需选择取消公钥原因和输入可选的其他描述内容。之后会要求输入密钥的通行句，完成验证后便会导出证书到revoke.txt。使用时导入revoke.txt并重新上传公钥至公钥服务器(导入公钥和上传公钥见下文)&lt;/p&gt;

&lt;h2&gt;导出密钥&lt;/h2&gt;

&lt;p&gt;公钥使用二进制文件保存(~/.gunpg/pubring.gpg)，可转换为ASCII导出，可用于上传至公钥服务器&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --armor --output ~/mykey.txt --export $GPGKEY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可输出私钥，使用&lt;code&gt;--export-secret-keys&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;上传公钥&lt;/h2&gt;

&lt;p&gt;公钥服务器专门存储用户公钥，且会相互同步，尽可能使用户公钥出现在所有公钥服务器上。可将自己的公钥上传至某个公钥服务器(如Ubuntu keyserver)，方便其他用户下载使用，也可以手动上传到多个公钥服务器加快同步进度&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --send-keys --keyserver keyserver.ubuntu.com $GPGKEY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可通过浏览器直接上传之前导出的公钥。由于任何人都可以向公钥服务器上传公钥，因此通常将公钥指纹(fingerprint)公布，方便使用者验证&lt;/p&gt;

&lt;h2&gt;导入公钥&lt;/h2&gt;

&lt;p&gt;可通过公钥服务器查找任何一份公钥&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --keyserver keyserver.ubuntu.com --search-keys $GPGKEY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要使用别人的公钥，需先导入至密钥数据库。首先获取对方的公钥，然后运行&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --import public-key.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认从stdin读入&lt;/p&gt;

&lt;h2&gt;密钥管理&lt;/h2&gt;

&lt;p&gt;列出所有密钥数据库中信息&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --list-keys
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;返回信息包括公钥、私钥特征和uid，如&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;${HOME}/.gnupg/pubring.gpg
---------------------------
pub   2048R/35D7ED67 2014-06-30
uid                  Yichen Zhao (First) &amp;lt;zebrap25@gmail.com&amp;gt;
sub   2048R/53055D3E 2014-06-30
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他显示额外内容的命令包括&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --list-sigs
gpg --fingerprint
gpg --list-secret-keys
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;删除指定uid的公钥，使用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --delete-keys $GPGKEY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;希望删除自己的公钥，需先删除私钥，使用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --delete-secret-keys $GPGKEY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;修改密钥指纹、签名等使用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --edit-key $GPGKEY
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入界面后可输入&lt;code&gt;help&lt;/code&gt;查看可操作内容&lt;/p&gt;

&lt;h1&gt;使用&lt;/h1&gt;

&lt;h2&gt;加密和解密&lt;/h2&gt;

&lt;p&gt;完成之前操作，便可使用密钥加密和解密信息。如将demo.txt加密后以demo.en.txt输出，使用的公钥通过&lt;code&gt;--recipient&lt;/code&gt;指明&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --recipient $GPGKEY --output demo.en.txt --encrypt demo.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解密，如接收到demo.en.txt，解密以demo.de.txt输出&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --output demo.de.txt --decrypt demo.en.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;code&gt;--decrypt&lt;/code&gt;可省略&lt;/p&gt;

&lt;h2&gt;签名和校验签名&lt;/h2&gt;

&lt;p&gt;若并不希望加密，仅希望给文件签名证明文件确实是我发的，使用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --sign demo.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导出的签名文件demo.txt.gpg将被压缩，是不可读的。若希望导出可读的文件使用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --clearsign demo.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导出签名文件demo.txt.asc。若希望保持原文件清晰，可将签名和原文件分开保存，使用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --detach-sign demo.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;推荐此方式，导出独立的签名文件demo.txt.sig是二进制文件，添加&lt;code&gt;--armor&lt;/code&gt;导出ASCII形式。若希望同时签名和加密，可执行集合了加密和签名选项的命令&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --local-user [sender-uid] --recipient $GPGKEY --armor --sign \
    --encrypt demo.txt
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;若文件同时加密和签名，校验签名在解密过程中完成。手动校验使用&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;gpg --verify demo.txt.sig
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中&lt;code&gt;--verify&lt;/code&gt;可省略&lt;/p&gt;

&lt;h1&gt;参看&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gnupg.org/&quot; title=&quot;The GNU Privacy Guard&quot;&gt;GnuPG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/GnuPG&quot; title=&quot;GnuPG&quot;&gt;GnuPG-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gnupg.org/howtos/zh/index.html&quot; title=&quot;Gnu隐私卫士(GnuPG)袖珍HOWTO(中文版)&quot;&gt;Gnu隐私卫士(GnuPG)袖珍HOWTO(中文版)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://help.ubuntu.com/community/GnuPrivacyGuardHowto&quot; title=&quot;GnuPrivacyGuardHowto&quot;&gt;GnuPrivacyGuardHowto&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/07/gpg.html&quot; title=&quot;GPG入门教程&quot;&gt;GPG入门教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Mon, 30 Jun 2014 00:00:00 +0800</pubDate>
				<link>http://zp.rensidiaochaotian.com//%E5%AE%89%E5%85%A8/2014/06/30/RSA%E5%9B%9B.html</link>
				<guid isPermaLink="true">http://zp.rensidiaochaotian.com//%E5%AE%89%E5%85%A8/2014/06/30/RSA%E5%9B%9B.html</guid>
			</item>
		
			<item>
				<title>开启Google now</title>
				<description>&lt;p&gt;看世界杯，还有Google I/O，突然就很想用Google now。好不容易找到一篇靠谱的文章，见参看。在Moto g测试成功了，超开心。记录方便以后再有需要。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;之前查了有提到把系统语言改为英文，然后语言搜索说&amp;#39;OK Google&amp;#39;就可以，然后就真试了...&lt;/em&gt;&lt;/p&gt;

&lt;h1&gt;操作过程&lt;/h1&gt;

&lt;h2&gt;Step 1&lt;/h2&gt;

&lt;p&gt;打开飞行模式，打开wifi确保网络连接正常&lt;/p&gt;

&lt;h2&gt;Step 2&lt;/h2&gt;

&lt;p&gt;进入Settings &amp;gt; Location &amp;gt; Mode，选择Device only模式&lt;/p&gt;

&lt;h2&gt;Step 3&lt;/h2&gt;

&lt;p&gt;安装应用: &lt;a href=&quot;https://play.google.com/store/apps/details?id=com.fakegps.mock&quot; title=&quot;伪装位置 Fake GPS Location&quot;&gt;伪装位置&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;Step 4&lt;/h2&gt;

&lt;p&gt;进入应用，设置任意一个美国境内的位置，如直接搜索&amp;#39;Miami&amp;#39;，然后按开始图标。过程中会要求开启mock location设置，在开发者选项中&lt;/p&gt;

&lt;h2&gt;Step 5&lt;/h2&gt;

&lt;p&gt;进入Settings，选择Accounts中的Google，选择Search &amp;gt; Google Account &amp;gt; Sign out，登出Google Search&lt;/p&gt;

&lt;h2&gt;Step 6&lt;/h2&gt;

&lt;p&gt;进入Settings &amp;gt; Apps &amp;gt; All，下拉找到Google Play services，进入后点击Disable，过程中会提示是否将Google Play services的更新卸载恢复到出厂，毫不犹豫点击确定。过程中会要求取消激活Android Device Manager，在Security &amp;gt; Device administrators中&lt;/p&gt;

&lt;h2&gt;Step 7&lt;/h2&gt;

&lt;p&gt;结束后重新进入Settings &amp;gt; Accounts &amp;gt; Google &amp;gt; Search &amp;gt; Google Account，这次是重新登录&lt;/p&gt;

&lt;h2&gt;Step 8&lt;/h2&gt;

&lt;p&gt;点击搜索框，下拉至底部，选择设置，打开Google Now，会进入设置页面，选择I&amp;#39;m in&lt;/p&gt;

&lt;h2&gt;Step 9&lt;/h2&gt;

&lt;p&gt;此时会要求重新打开Google Play Services并要求更新，必须更新。接着是结尾工作，关闭飞行模式，删除伪装位置应用，在Settings &amp;gt; Location &amp;gt; Mode中选择合适的模式&lt;/p&gt;

&lt;h2&gt;Step 10&lt;/h2&gt;

&lt;p&gt;开心的使用&lt;/p&gt;

&lt;h1&gt;参看&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://thenepalidroidguy.blogspot.com/2014/02/how-to-enable-google-now_6.html&quot; title=&quot;How to enable Google Now in Nepal and other countries (Solve - Google Location reporting not available in your region problem)&quot;&gt;How to enable Google Now in Nepal and other countries (Solve - Google Location reporting not available in your region problem)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Thu, 26 Jun 2014 00:00:00 +0800</pubDate>
				<link>http://zp.rensidiaochaotian.com//miscellaneous/2014/06/26/Google-now.html</link>
				<guid isPermaLink="true">http://zp.rensidiaochaotian.com//miscellaneous/2014/06/26/Google-now.html</guid>
			</item>
		
			<item>
				<title>非对称加密算法RSA和应用III - OPENVPN</title>
				<description>&lt;h1&gt;VPN&lt;/h1&gt;

&lt;p&gt;虚拟专用网(Virtual Private Network)是一种常用于连接中、大型企业或团体与团体间的私人网络的通讯方法。VPN可以实现通过不安全的网络架构(如因特网)，利用身份认证、加密等技术安全可靠的传输信息。常用的VPN协议有&lt;/p&gt;

&lt;h2&gt;PPTP&lt;/h2&gt;

&lt;p&gt;点对点隧道协议(PPTP)是微软、3Com等公司开发的虚拟隧道协议。PPTP使用TCP创建控制通道来发送控制命令，以及利用&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E8%B7%AF%E7%94%B1%E5%B0%81%E8%A3%85&quot; title=&quot;通用路由封装&quot;&gt;通用路由封装(GRE)&lt;/a&gt;通道来封装&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E7%82%B9%E5%AF%B9%E7%82%B9%E5%8D%8F%E8%AE%AE&quot; title=&quot;点对点协议&quot;&gt;点对点协议(PPP)&lt;/a&gt;数据包以发送数据。PPTP本身不提供加密和身份验证功能，需配合微软&lt;a href=&quot;http://msdn.microsoft.com/zh-cn/library/cc757532(v=ws.10).aspx&quot; title=&quot;Microsoft 点对点加密 (MPPE)&quot;&gt;点对点加密(MPPE)&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;L2TP&lt;/h2&gt;

&lt;p&gt;第二层隧道协议(Layer Two Tunneling Protocol)是由IETF根据PPTP提出的虚拟隧道协议，2005年L2TPv3通过RFC 3931发布。L2TP自身也不提供加密与身份验证，通常配合IPSec实现，称为L2TP/IPsec。L2TP是数据链路层协议，实现时不局限于IP网络，同时还支持ATM、帧中继、X.25在内的多种网络。&lt;/p&gt;

&lt;h2&gt;IPSec&lt;/h2&gt;

&lt;p&gt;互联网安全协定(Internet Protocol Security)是通过对IP协议的分组进行加密和认证来保护IP协议的网络传输协议族。IPSec属于网络层，通过加密封装IP数据包，可用于保护更高层的协议，如TCP、UDP等；而其他加密协议，如SSL位于应用层，则只能加密TCP信息流。但处于更低层则相应的必须处理可靠性和分片的问题，也使复杂性和处理开销较SSL高。&lt;/p&gt;

&lt;p&gt;若用于构建VPN(IPSec的主要用途)，由于处于网络层，数据包到达内部网络即解密，因此在内部局域网中是明文传输。而处于应用层的SSL能保证应用间的安全传输。&lt;/p&gt;

&lt;p&gt;开源软件&lt;a href=&quot;https://www.openswan.org/&quot; title=&quot;Openswan&quot;&gt;Openswan&lt;/a&gt;可提供IPsec功能。&lt;/p&gt;

&lt;h2&gt;SSLVPN&lt;/h2&gt;

&lt;p&gt;对比IPSec和SSL可以看出两者各自的优势，在某些情况下需要构建使用SSL加密的VPN。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://openvpn.net/&quot; title=&quot;OpenVPN&quot;&gt;OpenVPN&lt;/a&gt;是一个用于创建VPN的软件包，大量使用&lt;a href=&quot;http://www.openssl.org/&quot; title=&quot;OpenSSL&quot;&gt;OpenSSL&lt;/a&gt;加密库中的SSLv3/TLSv1协议函数库。其技术核心是虚拟网卡和SSL。虚拟网卡是使用网络底层编程技术实现的一个驱动软件，运行后主机多出现一个网卡，可像其他网卡一样配置，数据包都需通过此虚拟网卡处理。&lt;/p&gt;

&lt;p&gt;OpenVPN必须双向验证，也提供了多种验证方式，包括预享密钥(仅用于点对点VPN)、第三方证书、用户名密码组合(2.0起提供)。由于OpenVPN使用通用网络协议(TCP等)，因此可以防止ISP等过滤特定VPN协议，如IPSec。&lt;/p&gt;

&lt;h1&gt;搭建OpenVPN&lt;/h1&gt;

&lt;p&gt;整理这些内容实际是希望搭建一个VPN，在了解OpenVPN后引出了RSA算法和OpenSSL，于是就先做些准备，也方便之后使用HTTPS。教程参考&lt;a href=&quot;https://help.ubuntu.com/14.04/serverguide/openvpn.html&quot; title=&quot;OpenVPN&quot;&gt;Ubuntu服务指南中VPN内容&lt;/a&gt;，也参考了&lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-setup-and-configure-an-openvpn-server-on-centos-6&quot; title=&quot;How to Setup and Configure an OpenVPN Server on CentOS 6&quot;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;服务器端操作&lt;/h2&gt;

&lt;p&gt;Ubuntu 14.04，首先安装，OpenVPN2.3开始不捆绑easy-rsa(简化生成证书)，因此也需手动安装&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;apt-get update &amp;amp;&amp;amp; apt-get install openvpn easy-rsa
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由之前内容知道ssl运行需要密钥和数字证书，因此需先生成这些内容。复制easy-rsa到openvpn配置目录，然后编辑配置信息&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;mkdir /etc/openvpn/easy-rsa/
cp -r /usr/share/easy-rsa/* /etc/openvpn/easy-rsa/

cd /etc/openvpn/easy-rsa/
vim vars

# 配置，必填
export KEY_COUNTRY=&amp;quot;US&amp;quot;
export KEY_PROVINCE=&amp;quot;CA&amp;quot;
export KEY_CITY=&amp;quot;SanFrancisco&amp;quot;
export KEY_ORG=&amp;quot;Example Company&amp;quot;
export KEY_EMAIL=&amp;quot;me@myhost.mydomain&amp;quot;
export KEY_OU=&amp;quot;MyOrganizationalUnit&amp;quot;
export KEY_NAME=&amp;quot;EasyRSA&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着生成CA证书，为根证书(Root CA certificate)，教程把&lt;code&gt;source vars&lt;/code&gt;给翻译了...build-ca需要做一些选择，包括确认以上配置&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;source vars
./clean-all
./build-ca
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端身份验证最常用的是通过第三方证书，因此下一步生成客户端证书，通常每个客户端有各自不同的证书。另外，可选添加&amp;quot;HMAC firewall&amp;quot;来阻止Dos和UDP port flooding攻击，原理是在TLS/SSL更高层添加一个安全层，先过滤HMAC特征不符的UDP包，也起到加快处理作用，因为TLS/SSL操作比较消耗时间。期间需要做一些选择，如填写可选的一个密码和公司名称，确认时也记得输入&amp;#39;y&amp;#39;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;# 服务器证书
source vars
./build-key-server server

# 客户端证书
source vars
./build-key client1
./build-key client2

# 服务器必须生成D-H参数，增强安全性，具体为什么，再查一查
./build-dh

# 添加&amp;quot;HMAC firewall&amp;quot;，记得之后的配置
openvpn --genkey --secret ta.key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结束后，除ta.key位于/etc/openvpn外，其他生成的内容都位于./keys目录，其中包括&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ca.crt，Root CA certificate，服务器和所有客户端都需要一份，因此不需保密&lt;/li&gt;
&lt;li&gt;ca.key，Root CA key，用于签发私钥，保密&lt;/li&gt;
&lt;li&gt;dh{n}.pem，迪菲－赫尔曼变量&lt;/li&gt;
&lt;li&gt;server.crt，服务器证书，由根证书签发，其中包含服务器公钥，不需保密&lt;/li&gt;
&lt;li&gt;server.key，服务器私钥，必须保密&lt;/li&gt;
&lt;li&gt;client{n}.crt，客户端证书&lt;/li&gt;
&lt;li&gt;client{n}.key，客户端私钥&lt;/li&gt;
&lt;li&gt;ta.key，服务器和客户端都需要一份，但必须保密，因此必须在已存在的安全通道中传输&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;通常执行以下任务，方便之后的配置&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;cp server.crt server.key ca.crt dh2048.pem /etc/openvpn/
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;之后是简单的服务器配置&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;# 复制并解压配置文件
cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf.gz \
    /etc/openvpn/
gzip -d /etc/openvpn/server.conf.gz

cd /etc/openvpn
vim server.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;部分配置&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;# 确保以下内容写入配置文件
ca ca.crt
cert myservername.crt
key myservername.key 
dh dh2048.pem

# 其他自选配置；协议使用udp因为可更好的防止Dos和UDP port flooding攻击
prot 1194
proto udp
comp-lzo

# 若希望将服务器作为客户端的网关(目的很明确嘛)则需去除以下内容的注释
# 使用Google Public DNS
push &amp;quot;redirect-gateway def1 bypass-dhcp&amp;quot;
push &amp;quot;dhcp-option DNS 8.8.8.8&amp;quot;
push &amp;quot;dhcp-option DNS 8.8.4.4&amp;quot;

# 将OpenVPN作为非特权用户运行是很好的安全策略，取消两行注释
user nobody
group nogroup

# &amp;quot;HMAC firewall&amp;quot;配置，第二个参数在服务器端为0，客户端为1
tls-auth ta.key 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后一步，非常重要，路由转发配置(目的很明确嘛)&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;vim /etc/sysctl.conf

# 取消ip_forward注释
net.ipv4.ip_forward = 1

# 退出vim后重新载入sysctl
sysctl -p
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;依照教程，直接修改iptables；由于服务器使用了ufw，所以找到了对应的配置方式，详细见&lt;a href=&quot;http://www.gaggl.com/2013/04/openvpn-forward-all-client-traffic-through-tunnel-using-ufw/&quot; title=&quot;OpenVPN – forward all client traffic through tunnel using UFW&quot;&gt;这篇文章&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;# 直接修改iptables
iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -o eth0 -j MASQUERADE
service iptables save

# 或使用ufw配置
# 先配置允许封包转发
vim /etc/default/ufw
DEFAULT_FORWARD_POLICY=&amp;quot;ACCEPT&amp;quot;

# 之后修改规则
vim /etc/ufw/before.rules

# 以下内容需添加在&amp;quot;*filter&amp;quot;行前，就是添加在规则的最前端
# START OPENVPN RULES
# NAT table rules
*nat
:POSTROUTING ACCEPT [0:0]
# Allow traffic from OpenVPN client to eth0
-A POSTROUTING -s 10.8.0.0/8 -o eth0 -j MASQUERADE
COMMIT
# END OPENVPN RULES
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;服务器端任务完成，以服务开启&lt;code&gt;service openvpn start&lt;/code&gt;，或通过命令&lt;code&gt;openvpn&lt;/code&gt;开启。开启后可查看生成的虚拟网卡信息&lt;code&gt;ifconfig tun0&lt;/code&gt;。不要忘了开启端口&lt;code&gt;ufw allow 1194&lt;/code&gt;。一切正常，进入客户端操作&lt;/p&gt;

&lt;h2&gt;客户端操作&lt;/h2&gt;

&lt;p&gt;客户端内容均测试通过，其中桌面为Ubuntu 14.04；ios为7.1.1；android为4.4.2&lt;/p&gt;

&lt;h3&gt;Ubuntu&lt;/h3&gt;

&lt;p&gt;选择OpenVPN client，因此客户端也需安装OpenVPN，并将之前生成的client1.crt client1.key ca.crt移至/etc/openvpn&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf \
    /etc/openvpn/

cd /etc/openvpn
vim client.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;部分配置&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;# 确保以下内容写入配置文件
ca ca.crt
cert client1.crt
key client1.key

# 注意修改服务器地址，端口和协议必须与服务器相同，服务器开启压缩则客户端也必须开启
remote vpnserver.example.com 1194
prot 1194
proto udp
comp-lzo

# 将OpenVPN作为非特权用户运行是很好的安全策略，取消两行注释
user nobody
group nogroup

# &amp;quot;HMAC firewall&amp;quot;配置，第二个参数在服务器端为0，客户端为1
tls-auth ta.key 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置完成，可开启客户端&lt;code&gt;service openvpn start&lt;/code&gt;，同样也可以查看虚拟网卡信息&lt;code&gt;ifconfig tun0&lt;/code&gt;，ping服务器是否在线&lt;code&gt;ping 10.8.0.1&lt;/code&gt;，也可查看路由信息确定是否连接成功&lt;code&gt;netstat -rn&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;ios&lt;/h3&gt;

&lt;p&gt;app store下载官方OpenVPN Connect应用，编辑一份client.conf，将其重命名为.ovpn扩展名。将各种证书和密钥以in-line方式写入ovpn文件，具体样例见&lt;a href=&quot;https://community.openvpn.net/openvpn/wiki/IOSinline&quot; title=&quot;IOSinline&quot;&gt;此文&lt;/a&gt;。想办法将此配置文件移入ios设备，如通过邮件或iTunes同步等。完成后使用OpenVPN打开，跳转到OpenVPN后会看到有发现新配置的信息，右下方点击绿色的加号便可完成导入。打开服务测试。&lt;/p&gt;

&lt;h3&gt;android&lt;/h3&gt;

&lt;p&gt;android操作与ios几乎相同。安装官方OpenVPN Connect应用，制作ovpn文件后存入手机。打开OpenVPN，点击菜单，Import，选择ovpn文件导入。打开服务测试。&lt;/p&gt;

&lt;h2&gt;使用其他方式进行客户端身份认证&lt;/h2&gt;

&lt;p&gt;以上使用第三方证书方式认证，之前提到还有两种认证方式，静态密钥方式&lt;a href=&quot;http://openvpn.net/index.php/open-source/documentation/miscellaneous/78-static-key-mini-howto.html&quot; title=&quot;HOWTO-Static key configurations&quot;&gt;查看此文&lt;/a&gt;。另一种是OpenVPN2.0起可以选择的用户名/密码认证方式，简化认证，但我暂时不使用，没有经历就不太好发言，这里只是把手册中提到的设置方式整理出来，方便以后需要使用时查看。登录用户使用系统的local user和passwd。不需生成客户端证书，但ca.crt依然需要&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;text language-text&quot; data-lang=&quot;text&quot;&gt;# server.conf配置
# 声明使用openvpn-auth-pam扩展
plugin /usr/lib/openvpn/openvpn-plugin-auth-pam.so login

# 关闭证书认证而仅使用用户名/密码认证
client-cert-not-required
username-as-common-name


# client.conf配置
# 用户名和密码在连接时提供，加密传输给服务器后由以下配置触发认证
auth-user-pass

# 注释客户端证书和密钥内容
;cert client1.crt
;key client1.key
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;客户端连接时需输入用户名/密码。&lt;/p&gt;

&lt;h2&gt;避免被防火墙拦截&lt;/h2&gt;

&lt;p&gt;SSL在握手过程中是明文传输的，且看了几篇文章都说OpenVPN报文特征明显。有提到使用静态证书认证的，可以防止交换密钥时由于明显特征被阻拦OpenVPN服务的防火墙识别。还有是可以通过另一种不被拦截的服务通道传输OpenVPN报文，如SSH。&lt;/p&gt;

&lt;h1&gt;参看&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/OpenVPN&quot; title=&quot;OpenVPN&quot;&gt;OpenVPN-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E8%99%9B%E6%93%AC%E7%A7%81%E4%BA%BA%E7%B6%B2%E8%B7%AF&quot; title=&quot;虚拟专用网&quot;&gt;虚拟专用网-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E9%BB%9E%E5%B0%8D%E9%BB%9E%E9%9A%A7%E9%81%93%E5%8D%94%E8%AD%B0&quot; title=&quot;点对点隧道协议&quot;&gt;点对点隧道协议-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E7%AC%AC%E4%BA%8C%E5%B1%82%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE&quot; title=&quot;第二层隧道协议&quot;&gt;第二层隧道协议-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/IPsec&quot; title=&quot;IPsec&quot;&gt;IPsec-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.x-berry.com/vpn-tunneling-protocol/&quot; title=&quot;VPN 隧道协议PPTP、L2TP、IPSec和SSLVPN的区别&quot;&gt;VPN 隧道协议PPTP、L2TP、IPSec和SSLVPN的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://openvpn.net/index.php/open-source/documentation/howto.html&quot; title=&quot;HOWTO&quot;&gt;OpenVPN文档-HOWTO&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Tue, 24 Jun 2014 00:00:00 +0800</pubDate>
				<link>http://zp.rensidiaochaotian.com//%E5%AE%89%E5%85%A8/2014/06/24/RSA%E4%B8%89.html</link>
				<guid isPermaLink="true">http://zp.rensidiaochaotian.com//%E5%AE%89%E5%85%A8/2014/06/24/RSA%E4%B8%89.html</guid>
			</item>
		
			<item>
				<title>非对称加密算法RSA和应用II - HTTPS</title>
				<description>&lt;h1&gt;HTTPS&lt;/h1&gt;

&lt;p&gt;超文本传输安全协议是超文本传输协议和TLS/SSL的组合，用以提供加密通讯及对网络服务器身份的鉴定。HTTPS报文中的任何东西都被加密，包括所有报头和荷载，因此通常一个攻击者所能知道的只有在两者之间有一连接。&lt;/p&gt;

&lt;p&gt;HTTP和安全协议(TLS/SSL)都属于应用层。安全协议运行于HTTP之下，传输层之上，为HTTP提供一个类似于TCP的套接字。安全协议接收HTTP报文后将其加密，然后将加密结果交给传输层套接字；或从传输层套接字接收报文，解密后交给上层的HTTP。&lt;/p&gt;

&lt;p&gt;HTTPS通过数字证书进行身份认证，数字证书需向&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%9C%BA%E6%9E%84&quot; title=&quot;数字证书认证机构&quot;&gt;数字证书认证机构(Certificate Authority, CA)&lt;/a&gt;获取。浏览器需预先安装信任的CA的证书，也可手动导入(如goagent在local目录下找到ca.crt)，作用是证明此CA证书中列出的用户合法拥有证书中列出的公开密钥。关于&lt;em&gt;根证书(Root CA certificate)&lt;/em&gt;，CA也有上下级，且CA都有一份证书。下级CA的证书由上级颁发，由此一直到达最高级CA，它也有证书，且由自己给自己颁发，这个证书就称为根证书。&lt;/p&gt;

&lt;p&gt;一个到某网站的HTTPS连接可被信任，当且仅当：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用户相信互联网上相关的节点是值得信任的，或者本协议的加密层(TLS/SSL)不能被窃听者破坏&lt;/li&gt;
&lt;li&gt;用户相信证书颁发机构仅信任合法的网站&lt;/li&gt;
&lt;li&gt;用户相信他们的浏览器正确实现了HTTPS且安装了正确的证书颁发机构&lt;/li&gt;
&lt;li&gt;被访问的网站提供了一个有效的证书，即证书由一个被信任的证书颁发机构签发&lt;/li&gt;
&lt;li&gt;该证书正确地验证了被访问的网站&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这些信任之下，我可以认为网上交易对于我的金融账户是安全的。虽然看了这些觉得非常不安，但理论和事实同时证明目前这些信任还是没有问题的，我可以放心使用HTTPS。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;给自己的网站添加https功能将在之后尝试，可能有利于更多的对https的理解；先于OpenVPN因为其中包含CA内容。之后会修改内容&lt;/em&gt;&lt;/p&gt;

&lt;h1&gt;参看&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/HTTPS&quot; title=&quot;HTTPS&quot;&gt;HTTPS-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD&quot; title=&quot;PKI&quot;&gt;公开密钥基础建设-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Mon, 23 Jun 2014 00:00:00 +0800</pubDate>
				<link>http://zp.rensidiaochaotian.com//%E5%AE%89%E5%85%A8/2014/06/23/RSA%E4%BA%8C.html</link>
				<guid isPermaLink="true">http://zp.rensidiaochaotian.com//%E5%AE%89%E5%85%A8/2014/06/23/RSA%E4%BA%8C.html</guid>
			</item>
		
			<item>
				<title>非对称加密算法RSA和应用I - RSA 和 TLS/SSL</title>
				<description>&lt;h1&gt;公开密钥加密&lt;/h1&gt;

&lt;p&gt;公开密钥加密，也称为非对称(密钥)加密，是指一对加密密钥与解密密钥，这两个密钥数学相关。用某用户密钥加密后所得的信息，只能用该用户的解密密钥才能解密。如果知道了其中一个，并不能计算出另外一个。因此如果公开了一对密钥中的一个，并不会危害到另外一个的秘密性质。称公开的密钥为公钥；不公开的密钥为私钥。&lt;/p&gt;

&lt;p&gt;如果加密密钥是公开的，则称为公钥加密算法，常见有：&lt;a href=&quot;http://zh.wikipedia.org/wiki/Diffie-Hellman&quot; title=&quot;迪菲－赫尔曼密钥交换&quot;&gt;迪菲－赫尔曼密钥交换协议&lt;/a&gt;中的公钥加密算法，RSA等，其中使用最广泛的是RSA算法；若解密密钥是公开的，则称为私钥加密算法，应用如数字证书。&lt;/p&gt;

&lt;h1&gt;RSA&lt;/h1&gt;

&lt;p&gt;1977年在麻省理工学院工作的三位数学家Ron Rivest、Adi Shamir、Leonard Adleman一起提出了一种算法，以他们三人姓氏开头字母组成名称，即RSA算法。RSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中广泛使用。&lt;/p&gt;

&lt;p&gt;给出两个大质数，计算它们的乘积非常方便，但要是想对这个乘积做因数分解则非常困难，这个性质决定了RSA算法的可靠性。今天还没有任何可靠的攻击RSA算法的方式，通过暴力破解可破解短密钥，最长被破解密钥为768位，这威胁到了1024位密钥的安全性。但长密钥如2048位则可以认为是不可被破解的。&lt;/p&gt;

&lt;p&gt;以维基百科中一个实例说明RSA操作过程。操作中涉及到一些数学概念，具体可查看对应维基页面&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0&quot; title=&quot;欧拉函数&quot;&gt;欧拉函数&lt;/a&gt;，在&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%95%B0%E8%AE%BA&quot; title=&quot;数论&quot;&gt;数论&lt;/a&gt;中，对正整数n，欧拉函数φ(n)是小于或等于n的正整数中与n&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%BA%92%E8%B3%AA&quot; title=&quot;互素&quot;&gt;互质&lt;/a&gt;的数的数目。例中要使用欧拉函数的几条性质：

&lt;ul&gt;
&lt;li&gt;如果n=1，则φ(1) = 1&lt;/li&gt;
&lt;li&gt;如果n是质数，则φ(n)=n-1&lt;/li&gt;
&lt;li&gt;如果n可以分解成两个互质的整数之积，如n = p1p2，则φ(n) = φ(p1p2) = φ(p1)φ(p2)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86_(%E6%95%B0%E8%AE%BA)&quot; title=&quot;欧拉定理(数论)&quot;&gt;欧拉定理&lt;/a&gt;，是RSA算法的核心，如果两个正整数a和n互质，则a的φ(n)次方被n除的余数为1，即a^φ(n) ≡ 1 (mod n)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%A8%A1%E5%8F%8D%E5%85%83%E7%B4%A0&quot; title=&quot;模逆元素&quot;&gt;模反元素&lt;/a&gt;，如果两个正整数a和n互质，那么一定可以找到整数b，使得ab被n除的余数是1，即ab ≡ 1 (mod φ(n))&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;假设Alice希望通过一个不可靠媒体接收Bob的一条私人信息&lt;/p&gt;

&lt;h2&gt;公钥与私钥的产生&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Alice随机选取两个大的质数p和q，其中p!=q，N=pq&lt;/li&gt;
&lt;li&gt;根据欧拉函数，求得r = φ(N) = φ(p)φ(q) = (p-1)(q-1)&lt;/li&gt;
&lt;li&gt;选取小于r的整数e，e与r互质，计算e与r的模反元素d，即ed ≡ 1 (mod φ(N))；经化简得ed - kφ(N) = 1，其中已知e和φ(N)，实际就是解二元一次方程的整数解，其中两个已知数还满足互质，可通过&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95&quot; title=&quot;扩展欧几里得算法&quot;&gt;扩展欧几里得算法(辗转相除法的扩展)&lt;/a&gt;算出d和倍数k&lt;/li&gt;
&lt;li&gt;将p与q销毁，此时仅剩数N、r=φ(N)、e、d&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(N,e)是公钥，(N,d)是私钥。Alice将她的公钥(N,e)传给Bob，保留私钥(N,d)。这样产生的公钥和私钥可靠的原因是若要解密通信内容，需要知道d，若在有效保管d的条件下，想要通过e计算出d，则需通过&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ed ≡ 1 (mod φ(N))，要计算d需知道φ(N)&lt;/li&gt;
&lt;li&gt;φ(N) = φ(p)φ(q) = (p-1)(q-1)，若要知道φ(N)需知道p和q&lt;/li&gt;
&lt;li&gt;N=pq，也就是需要对N做因数分解，这是非常困难的&lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;加密消息&lt;/h2&gt;

&lt;p&gt;Bob需要向Alice发送信息m时，需将m转换为小于N的整数n，若字符串可转换为unicode等，若过长可分多片。通过公式 n^e ≡ c (mod N) 计算出c，c即为加密结果&lt;/p&gt;

&lt;h2&gt;解密消息&lt;/h2&gt;

&lt;p&gt;Alice接收到Bob发送的信息c，利用公式 c^d ≡ n (mod N) 计算出n，n即为信息内容&lt;/p&gt;

&lt;h2&gt;证明&lt;/h2&gt;

&lt;p&gt;为什么c^d ≡ n (mod N)可以解码密文？已知条件ed ≡ 1 (mod φ(N))可转换为ed = 1 + kφ(N)，证明的桥梁是c^d  ≡ n^(ed) (mod N)，证明中需使用&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%90%8C%E9%A4%98&quot; title=&quot;同余&quot;&gt;同余&lt;/a&gt;性质&lt;/p&gt;

&lt;h3&gt;若n与N互质&lt;/h3&gt;

&lt;p&gt;gcd(n, N)=1，由加密公式n^e ≡ c (mod N)可得c^d ≡ (n^e)^d ≡ n^(1+kφ(N)) ≡ n*n^(kφ(N)) (mod N)；n和N满足欧拉定理得n^φ(N) ≡ 1 (mod N)，因此c^d ≡ n*n^(kφ(N)) ≡ n (mod N)&lt;/p&gt;

&lt;h3&gt;若n与N不互质&lt;/h3&gt;

&lt;p&gt;gcd(n, N)!=1，因为N=pq，因此gcd(n, N)=p或q。先假设gcd(n, N)=p，则n=zp，n和q互质，依照欧拉定理，n^(q-1) ≡ 1 (mod q)，依照同余性质，n^[(q-1)(p-1)k]*n ≡ n (mod q)，化简得n^(ed) ≡ n (mod q)；此时将n=zp代入，同时转换为等式得zp*[(zp)^(ed-1) -1] = kq，由此看出zp可整除kq，k是p的整数倍，因此式子又可以写为n^(ed) = lpq + n，于是得到n^(ed) ≡ n (mod N)，通过桥梁c^d  ≡ n^(ed) (mod N)得到结果c^d ≡ n (mod N)；同理可证gcd(n, N)=q的情况&lt;/p&gt;

&lt;h1&gt;TLS/SSL&lt;/h1&gt;

&lt;p&gt;安全套接层(SSL)是一种安全协议，在网景公司推出首版Web浏览器的同时提出，目的是为网络通信提供安全及数据完整性保障，SSL在传输层中对网络通信进行加密。SSL采用公开密钥技术，在通行双方协商时可选择加密算法，而其中使用广泛的便是RSA算法。TLS是SSL标准化的产物，由&lt;a href=&quot;http://www.ietf.org/&quot; title=&quot;互联网工程任务组&quot;&gt;IETF&lt;/a&gt;制定，从技术上讲，TLS1.0与SSL3.0的差异非常微小。&lt;/p&gt;

&lt;p&gt;SSL协议的优势在于它是与应用层协议独立无关的。高层的应用层协议，如HTTP、FTP、Telnet等，能透明的建立于SSL协议之上。SSL协议在应用层协议通信之前就已经完成加密算法、通信密钥的协商以及服务器认证工作。在此之后应用层协议所传送的数据都会被加密，从而保证通信的私密性。&lt;/p&gt;

&lt;h2&gt;SSL工作方式&lt;/h2&gt;

&lt;p&gt;RSA等公开密钥加密技术效果好，但相比对称密钥加密，效率并不高。在实际应用中，SSL结合公共密钥和对称密钥实现功能：通信内容通过双方协商的会话唯一对称密钥加密提高效率，此对称密钥则通过服务器的公钥加密提供安全。为了保证公钥和源的可信，服务器通过数字证书传递公钥以便客户端验证。这些工作都在双方握手过程中完成&lt;/p&gt;

&lt;h3&gt;ClientHello&lt;/h3&gt;

&lt;p&gt;客户端向服务器发送ClientHello消息，信息内容包括&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;加密通信版本，如TLS1.0&lt;/li&gt;
&lt;li&gt;一个客户端生成的随机数，用于随后生成会话密钥&lt;/li&gt;
&lt;li&gt;支持的加密(RSA)和压缩算法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;ServerHello&lt;/h3&gt;

&lt;p&gt;服务器向客户端发送ServerHello消息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;确认使用的加密通信版本，若支持版本不一致则关闭通信&lt;/li&gt;
&lt;li&gt;一个服务器生成的随机数，用于随后生成会话密钥&lt;/li&gt;
&lt;li&gt;确认使用的加密方法&lt;/li&gt;
&lt;li&gt;服务器端证书，其中包含协商确定的加密方法的公钥&lt;/li&gt;
&lt;li&gt;若需客户端身份认证，则包含此项用于请求客户端证书(如网银要求连接U盾提供证书)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;客户端回复&lt;/h3&gt;

&lt;p&gt;客户端接收ServerHello消息后验证服务器端证书，从证书中取出公钥；客户端需生成第三个随机数，称为pre-master key，然后利用已有的3个随机数生成会话密钥，之后回复消息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若需客户端验证，则发送客户端证书&lt;/li&gt;
&lt;li&gt;利用公钥加密后的pre-master key&lt;/li&gt;
&lt;li&gt;编码改变通知，即说明之后内容都通过加密传输&lt;/li&gt;
&lt;li&gt;握手结束通知，是之前发送的所有内容的hash，用于校验&lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt;服务器回复&lt;/h3&gt;

&lt;p&gt;服务器收到信息后利用私钥解密得到pre-master key，利用所有3个随机数生成会话密钥，然后回复消息&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;若需客户端验证，且验证不通过，则关闭通信&lt;/li&gt;
&lt;li&gt;编码改变通知，即说明之后内容都通过加密传输&lt;/li&gt;
&lt;li&gt;握手结束通知，是之前发送的所有内容的hash，用于校验&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用3个随机数生成会话密钥，因为要保证每个对话都有不同的密钥，由双方独立生成的伪随机数可能并非真正随机，引入pre-master key增加自由度保证随机性可靠；因为之前两个随机数都是明文传输，通过加密传输pre-master key也保证会话密钥的安全&lt;/p&gt;

&lt;p&gt;&lt;em&gt;数论太神奇了&lt;/em&gt;&lt;/p&gt;

&lt;h1&gt;参看&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5&quot; title=&quot;公开密钥加密&quot;&gt;公开密钥加密-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%B0%8D%E7%A8%B1%E5%AF%86%E9%91%B0%E5%8A%A0%E5%AF%86&quot; title=&quot;对称密钥加密&quot;&gt;对称密钥加密-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/RSA%E5%8A%A0%E5%AF%86%E6%BC%94%E7%AE%97%E6%B3%95&quot; title=&quot;RSA加密算法&quot;&gt;RSA加密算法-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/zh-cn/%E5%AE%89%E5%85%A8%E5%A5%97%E6%8E%A5%E5%B1%82&quot; title=&quot;安全套接层&quot;&gt;安全套接层-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/zh-cn/OpenSSL&quot; title=&quot;OpenSSL&quot;&gt;OpenSSL-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html&quot; title=&quot;RSA算法原理（一）&quot;&gt;RSA算法原理（一）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html&quot; title=&quot;RSA算法原理（二）&quot;&gt;RSA算法原理（二）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html&quot; title=&quot;SSL/TLS协议运行机制的概述&quot;&gt;SSL/TLS协议运行机制的概述&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Sat, 21 Jun 2014 00:00:00 +0800</pubDate>
				<link>http://zp.rensidiaochaotian.com//%E5%AE%89%E5%85%A8/2014/06/21/RSA%E4%B8%80.html</link>
				<guid isPermaLink="true">http://zp.rensidiaochaotian.com//%E5%AE%89%E5%85%A8/2014/06/21/RSA%E4%B8%80.html</guid>
			</item>
		
			<item>
				<title>IEEE 754 - 二进制浮点数算术标准</title>
				<description>&lt;h1&gt;简介&lt;/h1&gt;

&lt;p&gt;二进制浮点数算术标准(IEEE 754)是由&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E7%94%B5%E6%B0%94%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%BC%9A&quot; title=&quot;电气电子工程师学会&quot;&gt;电气电子工程师学会&lt;/a&gt;在1985年提出的关于浮点数运算的技术标准，称为IEEE 754-1985。IEEE 854则是IEEE在两年后提出的与基数无关浮点数运算的技术标准，称为IEEE 854-1987。2008年8月，IEEE 754-2008发布，是目前使用的最新版本，其中几乎包括所有IEEE 754-1985规定的标准和IEEE 854-1987内容。相对应的国际标准为ISO/IEC/IEEE 60559:2011。&lt;/p&gt;

&lt;p&gt;早期各计算机公司不同型号的计算机有着各自千差万别的浮点数表示方式，这给不同机器间数据交换和协同工作造成了极大的不便。1980年，英特尔发布&lt;a href=&quot;http://zh.wikipedia.org/wiki/Intel_8087&quot; title=&quot;Intel 8087&quot;&gt;Intel 8087 数学辅助处理器&lt;/a&gt;用于加速应用程序有关浮点运算的运算需求。之后IEEE以8087的浮点表示法和运算规范为标准提出了IEEE 754。现在许多&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E5%99%A8&quot; title=&quot;浮点运算器&quot;&gt;FPU(floating point units)&lt;/a&gt;都支持此标准。&lt;/p&gt;

&lt;h1&gt;规范&lt;/h1&gt;

&lt;p&gt;规范中定义的内容包括&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;表示方式，包括二进制和十进制浮点数的有限值、无穷值(Inf)和非数值(NaN)的表示方式&lt;/li&gt;
&lt;li&gt;转换规范，将浮点数转换为定长bit-string&lt;/li&gt;
&lt;li&gt;运算过程中的舍、入规范&lt;/li&gt;
&lt;li&gt;算术运算和其他运算相关的规范&lt;/li&gt;
&lt;li&gt;异常处理，如除数为0时如何处置&lt;/li&gt;
&lt;li&gt;其他建议&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;规定有限浮点数使用下方格式表示&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(−1)^s × c × b^q&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;s为符号位，1为负数，0正数&lt;/li&gt;
&lt;li&gt;c为有效数字&lt;/li&gt;
&lt;li&gt;b为基数，2或10&lt;/li&gt;
&lt;li&gt;q为指数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;规范规定5种基本浮点数表示方式，其中称为binary32的单精度浮点数，对应c中的float，占用32bit，规定这32bit表示方式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;符号位s为最高位，占1位，1为负数，0正数&lt;/li&gt;
&lt;li&gt;指数q紧跟s，占8位&lt;/li&gt;
&lt;li&gt;余下23位为有效数字c&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;binary64，双精度浮点数，对应c中的double，q为11位(范围-1022～1023)，c为52位&lt;/p&gt;

&lt;h2&gt;例&lt;/h2&gt;

&lt;p&gt;数字-5，二进制为-101，使用规定格式表示为(-1)^1*1.01*2^2，因此s=1，q=2，c=1.01，初步确定完整32位为&lt;/p&gt;

&lt;p&gt;1|00,000,010|10,100,000,000,000,000,000,000&lt;/p&gt;

&lt;h2&gt;有效数字c&lt;/h2&gt;

&lt;p&gt;因为在二进制中，其最高位总是1(若0总可以通过几次指数q-1转为1)，因此规范规定表示时省略有效数字的第一位而直接由第二位开始记录，读取时则自动补上1。因此虽然留给有效数字23位，但实际可表示24位内容。如例中，完整32位应改为&lt;/p&gt;

&lt;p&gt;1|00,000,010|01,000,000,000,000,000,000,000&lt;/p&gt;

&lt;h2&gt;指数q&lt;/h2&gt;

&lt;p&gt;8位的q可以表示的范围为0-255，但指数可能出现负数，因此规定给出中间值127，8位q计算出的结果都需要减去127，之后的值是实际的指数，q范围-126～127；其中又有特例&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;q非全0或非全1，使用以上规则&lt;/li&gt;
&lt;li&gt;q全0，最小的指数，也就自然用于表示&lt;strong&gt;无穷小&lt;/strong&gt;以及其&lt;strong&gt;极限0&lt;/strong&gt;，此时有效数字c在读取时不补上1(理解：若有效数字c全为0则表示0，此时要是补1不合适)，q则为0-127+1=-126(理解：+1因为有效数字实际是补了0，即0.xxx，小数点左移1位，因此指数+1)&lt;/li&gt;
&lt;li&gt;q全1，最大的指数，若此时有效数字c全为0则表示&lt;strong&gt;无穷大&lt;/strong&gt;，正负则由s决定；若c不全为0，则表示NaN&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例中转换时q应进行操作2+127=129，最终32位应改为&lt;/p&gt;

&lt;p&gt;1|10,000,001|01,000,000,000,000,000,000,000&lt;/p&gt;

&lt;h1&gt;参看&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.cs.berkeley.edu/%7Ewkahan/ieee754status/IEEE754.PDF&quot; title=&quot;IEEE Standard 754 for Binary Floating-Point Arithmetic&quot;&gt;IEEE Standard 754 for Binary Floating-Point Arithmetic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/IEEE_754&quot; title=&quot;IEEE 754&quot;&gt;IEEE 754-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_floating_point&quot; title=&quot;IEEE floating point&quot;&gt;IEEE floating point-wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/IEEE_854-1987&quot; title=&quot;IEEE 854-1987&quot;&gt;IEEE 854-1987-wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html&quot; title=&quot;浮点数的二进制表示&quot;&gt;浮点数的二进制表示&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Wed, 04 Jun 2014 00:00:00 +0800</pubDate>
				<link>http://zp.rensidiaochaotian.com//%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/2014/06/04/IEEE-754.html</link>
				<guid isPermaLink="true">http://zp.rensidiaochaotian.com//%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/2014/06/04/IEEE-754.html</guid>
			</item>
		
			<item>
				<title>开机过程和名词解释IV - 操作系统</title>
				<description>&lt;h1&gt;操作系统阶段&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;之前记录的可认为是Linux启动的第一个概念阶段，其性能提升主要来自硬件升级；在内核加载和操作系统获取到控制权之后，启动进入第二个概念阶段，此时性能提升几乎完全来自软件。&lt;/em&gt;&lt;/p&gt;

&lt;h2&gt;vmlinuz&lt;/h2&gt;

&lt;p&gt;在linux系统中，vmlinux(vmlinuz)是一个包含linux kernel的链接文件。内核压缩文件位于/boot，类似/boot/vmlinux-3.13.0-24-generic。我在/root下找到了vmlinux文件。&lt;/p&gt;

&lt;p&gt;GRUB将内核压缩文件载入内存，通常为zImage或bzImage。在这个内核映像前面是一个例程，它实现少量硬件设置，并对内核映像中包含的内核进行解压。然后该例程会调用内核，并开始启动内核引导的过程。&lt;/p&gt;

&lt;h2&gt;initrd&lt;/h2&gt;

&lt;p&gt;与内核一同被GRUB加载入内存的还有initrd。Initial RAM disk或者initrd是指一个临时文件系统，它在启动阶段被Linux内核调用。initrd主要用于根文件系统被挂载之前，进行准备工作。Linux2.6内核的initrd的文件格式由原来的文件系统镜像文件转变成了&lt;a href=&quot;http://zh.wikipedia.org/wiki/Cpio&quot; title=&quot;Cpio&quot;&gt;cpio&lt;/a&gt;格式，文件位于/boot，在/root下找到链接文件initrd.img。&lt;/p&gt;

&lt;p&gt;Linux可以动态载入核心模块，如设备驱动等，精简内核同时提高灵活，存储在/lib/modules中。文件系统可以存储在包括IDE、SCSI、USB在内的多种介质中。若要挂载存储设备中的文件系统，则先要访问此存储设备，获取存储在文件系统中的设备驱动以便驱动此存储设备提供访问可能，非常矛盾的关系。此时initrd便出现以解决此问题。&lt;/p&gt;

&lt;p&gt;内核在访问真正的文件系统前先访问initrd文件系统。相较于Linux2.4内核文件系统镜像，cpio格式的initrd在处理流程上简化了不少。GRUB将initrd释放到rootfs(基于内存的文件系统，因此不需要任何驱动)，然后执行initrd中的/init文件，执行到这一点，内核的工作全部结束，完全交给/init文件处理。之前版本在挂载initrd后执行/linuxrc加载访问根文件系统必须的驱动，卸载initrd后加载根文件系统，并执行/sbin/init。&lt;/p&gt;

&lt;h2&gt;init&lt;/h2&gt;

&lt;p&gt;当内核被引导并进行初始化之后，内核就可以启动自己的第一个用户空间应用程序了。这是第一个调用的使用标准C库编译的程序。在此之前，还没有执行任何标准的C应用程序。init(initialization)是Unix和类Unix系统中用来产生其它所有进程的程序。它以守护进程的方式存在，其进程号为1。init进程非常独特，能够完成其他进程无法完成的任务。&lt;/p&gt;

&lt;p&gt;init系统能够定义、管理和控制init进程的行为。它负责组织和运行许多独立的或相关的初始化工作，从而让计算机系统进入某种用户预订的运行模式，如启动shell或进入图形界面。&lt;/p&gt;

&lt;p&gt;init系统不断发展，早先的&lt;a href=&quot;http://zh.wikipedia.org/wiki/Sysvinit&quot; title=&quot;Sysvinit&quot;&gt;Sysvinit&lt;/a&gt;，来自Ubuntu被各发行版普遍使用的&lt;a href=&quot;http://zh.wikipedia.org/wiki/Upstart&quot; title=&quot;Upstart&quot;&gt;Upstart&lt;/a&gt;，有取代Upstart趋势的&lt;a href=&quot;http://zh.wikipedia.org/wiki/Systemd&quot; title=&quot;systemd&quot;&gt;systemd&lt;/a&gt;；随着Debian Jessie默认使用systemd，Ubuntu也确定将采用systemd&lt;/p&gt;

&lt;p&gt;运行模式描述了系统各种可能的状态。通常有8种运行模式，即运行模式0到6和S或s。其中有3个保留运行模式&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0，关机&lt;/li&gt;
&lt;li&gt;1，单用户模式&lt;/li&gt;
&lt;li&gt;6，重启&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其余依照不同发行版有不同选择。每个运行模式X都有一个对应目录/etc/rcX.d存放启动|关闭脚本，每个脚本名称都有规范的前缀，如启动脚本S开头，关闭脚本K开头，接着的数字为启动|关闭顺序。这些脚本都是软连接，实际位于/etc/init.d。/etc/rc.local是留给用户进行个性化设置的地方，最后执行&lt;/p&gt;

&lt;h1&gt;参看&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/Vmlinux&quot; title=&quot;vmlinux&quot;&gt;vmlinux-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/Initrd&quot; title=&quot;initrd&quot;&gt;initrd-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/l-k26initrd/&quot; title=&quot;Linux2.6 内核的 Initrd 机制解析&quot;&gt;Linux2.6 内核的 Initrd 机制解析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/Init&quot; title=&quot;init&quot;&gt;init-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html&quot; title=&quot;Linux 的启动流程&quot;&gt;Linux 的启动流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/l-customize-monitor-linux/index.html?ca=drs-&quot; title=&quot;定制和监视 Linux 系统启动&quot;&gt;定制和监视 Linux 系统启动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://linux.vbird.org/linux_basic/0510osloader.php#startup_intro&quot; title=&quot;開機流程、模組管理與 Loader&quot;&gt;開機流程、模組管理與 Loader-鳥哥的 Linux 私房菜&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/index.html&quot; title=&quot;浅析 Linux 初始化 init 系统，第 1 部分: sysvinit&quot;&gt;浅析 Linux 初始化 init 系统，第 1 部分: sysvinit&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/index.html?ca=drs-&quot; title=&quot;浅析 Linux 初始化 init 系统，第 2 部分: UpStart&quot;&gt;浅析 Linux 初始化 init 系统，第 2 部分: UpStart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/index.html?ca=drs-&quot; title=&quot;浅析 Linux 初始化 init 系统，第 3 部分: Systemd&quot;&gt;浅析 Linux 初始化 init 系统，第 3 部分: Systemd&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Sun, 11 May 2014 00:00:00 +0800</pubDate>
				<link>http://zp.rensidiaochaotian.com//%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/2014/05/11/%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B%E5%92%8C%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E5%9B%9B.html</link>
				<guid isPermaLink="true">http://zp.rensidiaochaotian.com//%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/2014/05/11/%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B%E5%92%8C%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E5%9B%9B.html</guid>
			</item>
		
			<item>
				<title>开机过程和名词解释III - GRUB</title>
				<description>&lt;h1&gt;GNU GRUB&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;GNU GRUB(Grand Unified Boot Loader)是一个来自&lt;a href=&quot;http://zh.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83&quot; title=&quot;GNU计划&quot;&gt;GNU项目&lt;/a&gt;的启动引导程序，主要用于类Unix系统。其任务是加载操作系统内核并移交控制权。允许用户选择要载入的已安装的操作系统或内核，也允许用户向​内​核​传​递​参​数。当前稳定版为2.00(GRUB2)，官方所称GRUB即GRUB2，前一版本称为GRUB Legacy。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;GRUB功能强大，如支持直接和链式载入方式，几乎可引导任何操作系统；支持所有Unix文件系统和Windows适用的FAT、NTFS文件系统；从网络下载操作系统镜像而支持无盘系统；GRUB提示符交互功能等。&lt;/p&gt;

&lt;h2&gt;基于BIOS和MBR的GRUB引导过程&lt;/h2&gt;

&lt;p&gt;GRUB阶段1程序(boot.img)位于MBR中。MBR引导程序作用是定位GRUB，并将阶段1载入内存。受MBR空间影响，阶段1所做几乎只是装载阶段2。阶段2载入内存，作用是显示GRUB菜单和命令环境，提供选择操作系统或内核、传递参数给内核和查看系统参数功能。完成选择后GRUB将内核载入内存，然后移交控制权给内核，由内核载入操作系统。&lt;/p&gt;

&lt;p&gt;以上方式称为直接载入(direct loading)，GRUB还支持Windows使用的链式载入(chain loading)。此方式下，MBR指向存放操作系统的分区的第一个扇区，找到所需文件(另一个启动器)来引导操作系统。&lt;/p&gt;

&lt;h2&gt;基于UEFI的GRUB引导过程&lt;/h2&gt;

&lt;p&gt;EFI挂载EFI系统分区(/boot/efi/)，Ubuntu提供的EFI软件位于/boot/efi/EFI/ubuntu/，其中包含EFI固件架构编译的grubx64.efi文件。grubx64.efi作为缺省的引导程序被读入内存，可以选择操作系统，并进行控制权移交。对于基于UEFI的系统，链加载通常不是必需的。EFI引导管理者可以加载EFI系统分区里出现的任何操作系统引导加载程序。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;GRUB移交控制权后，接下去的工作便交由操作系统完成。&lt;/em&gt;&lt;/p&gt;

&lt;h1&gt;参看&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F&quot; title=&quot;引导程序&quot;&gt;引导程序-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/GNU_GRUB&quot; title=&quot;GNU GRUB&quot;&gt;GRUB-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.gnu.org/software/grub/&quot; title=&quot;GNU GRUB&quot;&gt;GNU GRUB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wiki.archlinux.org/index.php/GRUB&quot; title=&quot;GRUB&quot;&gt;GRUB-Archlinux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://access.redhat.com/site/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html/Installation_Guide/s1-grub-whatis.html&quot; title=&quot;基​于​BIOS的​x86系​统​上​的​GRUB和​引​导​过​程​&quot;&gt;基​于​BIOS的​x86系​统​上​的​GRUB和​引​导​过​程​&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://access.redhat.com/site/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html/Installation_Guide/s2-grub-whatis-booting-uefi.html&quot; title=&quot;基​于​UEFI的​x86系​统​上​的GRUB和​引​导​过​程​&quot;&gt;基​于​UEFI的​x86系​统​上​的GRUB和​引​导​过​程​&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/LILO&quot; title=&quot;LILO&quot;&gt;LILO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/NTLDR&quot; title=&quot;NTLDR&quot;&gt;NTLDR-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Tue, 29 Apr 2014 00:00:00 +0800</pubDate>
				<link>http://zp.rensidiaochaotian.com//%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/2014/04/29/%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B%E5%92%8C%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E4%B8%89.html</link>
				<guid isPermaLink="true">http://zp.rensidiaochaotian.com//%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/2014/04/29/%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B%E5%92%8C%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E4%B8%89.html</guid>
			</item>
		
			<item>
				<title>开机过程和名词解释II - MBR 和 GPT</title>
				<description>&lt;h1&gt;MBR&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;主引导记录(Master Boot Record, MBR)是计算机开机访问硬盘时必须读取的首个扇区，三维地址为(柱面, 磁头, 扇区) = (0, 0, 1)。MBR存储硬盘本身的相关信息和分区的大小及位置信息，是数据信息的重要入口。MBR与操作系统无关。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;MBR(512bytes)分3部分&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;前446bytes存储引导代码，也称为MBR&lt;/li&gt;
&lt;li&gt;接着4个16bytes的磁盘分区表(DPT)&lt;/li&gt;
&lt;li&gt;最后是2bytes结束标志，0x55和0xAA&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;BIOS按启动顺序依次读取存储设备的MBR，若未发现结束标志，则操作下一存储设备。若无合适设备，则显示相应错误信息并死机，否则将控制权交给此设备。启动设备运行引导代码，作用是检查分区表是否正确并且在系统硬件完成自检以后将控制权交给硬盘上的第二阶段引导程序(如GNU GRUB)。&lt;/p&gt;

&lt;p&gt;DPT共64bytes，可对4个分区的信息进行描述，每个16bytes。每个字节具体定义为&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;00H，1byte，分区状态，非活动分区00，活动分区80，其他无意义&lt;/li&gt;
&lt;li&gt;01H，1byte，分区起始磁头号(HEAD)，全8位&lt;/li&gt;
&lt;li&gt;02H，2bytes，分区起始扇区号(SECTOR),占据02H的0-5位；分区起始柱面号(CYLINDER),占据02H的6-7位和全部03H的8位&lt;/li&gt;
&lt;li&gt;04H，1byte，文件系统标志位，如0B为FAT32&lt;/li&gt;
&lt;li&gt;05H，1byte，分区结束磁头号，全8位&lt;/li&gt;
&lt;li&gt;06H，2bytes，分区结束扇区号，占据06H的0-5位；分区结束柱面号，占据06H的6-7位和07H的8位&lt;/li&gt;
&lt;li&gt;08H，4bytes，分区起始相对扇区号&lt;/li&gt;
&lt;li&gt;0CH，4bytes，分区总扇区数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;由上可知，采用MBR型分区结构的硬盘最多只能有4个主分区(Primary partition)。为了得到更多分区，需要引入扩展分区，可在其中划分无数个逻辑分区。MBR分区表中最多只能有1个扩展分区，且Linux中扩展分区的分区号只能从5(如sda5)开始；对于大于8.4G的硬盘，CHS(24位)已无法表示，需使用&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E9%82%8F%E8%BC%AF%E5%8D%80%E5%A1%8A%E4%BD%8D%E5%9D%80&quot; title=&quot;逻辑区块地址&quot;&gt;LBA(Logical Block Address)&lt;/a&gt;；4bytes扇区总数限制分区大小，最大2T，且每个分区的起始柱面必须在这个硬盘的前2T内。因此若有一块3T硬盘，则至少需要划分为两个分区，且第二个分区起始柱面需在前2T空间内。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;以上各种分区、空间局限都在促使更合适的技术产生。&lt;/em&gt;&lt;/p&gt;

&lt;h1&gt;GPT&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;全局唯一标识分区表(GUID Partition Table, GPT)是一个实体硬盘的分区表的结构布局标准。GPT是EFI标准的一部分，用于替代MBR。多数操作系统已支持GPT，部分仅支持在EFI基础上自GPT启动，如Windows、OS X；Linux支持GPT用于基于BIOS的系统。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;GPT使用LBA，以64位Windows为例(每个逻辑块512bytes)&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;LBA 0，传统MBR&lt;/li&gt;
&lt;li&gt;LBA 1，GPT头(分区表头)&lt;/li&gt;
&lt;li&gt;LBA 2，分区表，使用32个逻辑块(16,384bytes)&lt;/li&gt;
&lt;li&gt;LBA 34，第一个分区开始&lt;/li&gt;
&lt;li&gt;LBA -2，备份分区表&lt;/li&gt;
&lt;li&gt;LBA -1，备份GPT头，位于最后一个逻辑块&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GPT保留传统MBR，称为保护MBR，用于防止不支持GPT的硬盘管理工具错误识别并破坏硬盘中的数据。在支持从GPT启动的操作系统中，这里也用于存储第一阶段的启动代码，并且其中只有一个标识为0xEE的分区，以此来表示使用GPT分区表。在使用MBR/GPT混合分区表的硬盘中，MBR也用于存储GPT分区表的部分分区(通常前4个)以运行不支持GPT的操作系统。&lt;/p&gt;

&lt;p&gt;GPT分区硬盘通过备份分区表头和分区表来提高分区数据结构的完整性，通过CRC32校验提高数据可靠性。分区表头定义了硬盘的可用空间以及组成分区表的项的大小和数量，还记录了这块硬盘的GUID、分区表头本身的位置和大小(位置总是在LBA 1)、备份分区表头和分区表的位置和大小(在硬盘的最后)、其本身和分区表的CRC32校验。&lt;/p&gt;

&lt;p&gt;GPT分区表结构简单，每个分区信息占128bytes，每个字节具体含义&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;16bytes，分区类型GUID(如EFI系统分区)&lt;/li&gt;
&lt;li&gt;16bytes，分区GUID&lt;/li&gt;
&lt;li&gt;8bytes，起始LBA&lt;/li&gt;
&lt;li&gt;8bytes，末尾LBA&lt;/li&gt;
&lt;li&gt;8bytes，属性标签(如60为只读)&lt;/li&gt;
&lt;li&gt;72bytes，分区名&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;相对于2T卷大小限制的MBR，GPT分配8bytes给逻辑块地址，理论最大分区大小可为2^64-1个扇区。除超大卷外，GPT无分区个数限制，但实际需受操作系统限制，如64位Windows分区表为16,384bytes，即最多可有128个分区。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;EFI完成初始化和运行DXE后挂载EFI系统分区(ESP)，剩余工作完成后将控制权交给位于此分区的第二阶段引导程序，如GRUB。&lt;/em&gt;&lt;/p&gt;

&lt;h1&gt;参看&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95&quot; title=&quot;主引导记录&quot;&gt;MBR-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%E6%A8%99%E8%AD%98%E5%88%86%E5%8D%80%E8%A1%A8&quot; title=&quot;全局唯一标识分区表&quot;&gt;GPT-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Sun, 27 Apr 2014 00:00:00 +0800</pubDate>
				<link>http://zp.rensidiaochaotian.com//%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/2014/04/27/%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B%E5%92%8C%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E4%BA%8C.html</link>
				<guid isPermaLink="true">http://zp.rensidiaochaotian.com//%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/2014/04/27/%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B%E5%92%8C%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E4%BA%8C.html</guid>
			</item>
		
			<item>
				<title>开机过程和名词解释I - BIOS 和 UEFI</title>
				<description>&lt;h1&gt;BIOS&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;BIOS(Basic Input/Output System)在&lt;a href=&quot;http://zh.wikipedia.org/wiki/IBM_PC%E5%85%BC%E5%AE%B9%E6%9C%BA&quot; title=&quot;IBM PC兼容机&quot;&gt;IBM PC兼容机&lt;/a&gt;(标准PC)上，是一种业界标准的固件接口，是个人电脑启动时加载的第一个软件。1975年在&lt;a href=&quot;http://zh.wikipedia.org/wiki/CP/M&quot; title=&quot;CP/M操作系统&quot;&gt;CP/M&lt;/a&gt;(&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E7%A0%94%E7%A9%B6%E5%85%AC%E5%8F%B8&quot; title=&quot;数字研究公司&quot;&gt;DRI&lt;/a&gt;)中第一次出现名词BIOS。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;BIOS存储在特定的EEPROM或闪存中，系统过电或被重置(reset)时，处理器第一条指令的地址会被定位到BIOS的存储器中。BIOS从存储器中解压到主存，让初始化程序开始运行，包括执行系统各部分的的自检(Power-On Self-Test, POST)，启动引导程序或装载操作系统。接下去BIOS将控制权交给下一阶段程序，判断依据为用户参数(存储于CMOS)的启动顺序(Boot Sequence)，如从硬盘启动。&lt;/p&gt;

&lt;p&gt;BIOS利用挂载真实模式中断的方式增加硬件功能，必须将一段类似驱动的16位代码存于固定的存储区，运行这段代码，它将挂载实模式下约定的中断矢量向其他程序提供服务。驱动代码受存储区限制。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;BIOS技术发展缓慢，自从出现以来就以16位汇编代码，寄存器参数调用方式，静态链接，以及1MB以下内存固定编址的形式存在了十几年。虽然功能也有增强，但在BIOS中添加几个简单的USB设备支持都曾使很多BIOS设计师痛苦万分。有问题，于是UEFI出现了。&lt;/em&gt;&lt;/p&gt;

&lt;h1&gt;UEFI&lt;/h1&gt;

&lt;p&gt;&lt;em&gt;UEFI(Unified Extensible Firmware Interface, 统一可扩展固件接口)最初由英特尔开发，名为EFI，用来定义操作系统和固件之间的软件界面，为替代BIOS的升级方案。2005年英特尔将此规范格式交由&lt;a href=&quot;http://www.uefi.org/&quot; title=&quot;Unified Extensible Firmware Interface Forum&quot;&gt;UEFI论坛&lt;/a&gt;推广与发展，之后改名为UEFI。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;EFI在概念上非常类似一个低阶操作系统，包括操作界面优化和鼠标代替键盘作为输入。&lt;strong&gt;重要的&lt;/strong&gt;，启动时，会加载硬件在EFI中的驱动程序。这些驱动用EFI Byte Code编写。这种虚拟机器语言并不由CPU直接执行，需在EFI驱动运行环境(Driver Execution Environment, DXE)下被解释运行。硬件被保护起来，操作系统则摆脱驱动，通过API操作硬件，保证了充分的向下兼容性。EFI对硬件有完全的控制权，不需要进入操作系统，只需进入EFI操作界面便可安装和更新硬件驱动。&lt;/p&gt;

&lt;p&gt;EFI需要远大于BIOS的存储空间，在磁盘中以小型分区形式存在(EFI系统分区，fat32，通常大于100M，200M较合适，boot flag，具体见GPT和GRUB相关)。EFI是用模块化，C语言风格的参数堆栈传递方式，动态链接的形式构建的系统。突破16位寻址而适用于现在的处理器模式。高级语言的运用简化开发，方便硬件厂商参与。&lt;/p&gt;

&lt;p&gt;EFI一般由以下部分组成&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Pre-EFI初始化模块&lt;/li&gt;
&lt;li&gt;DXE - Pre-EFI和DXE通常被集成在一个只读存储器中&lt;/li&gt;
&lt;li&gt;EFI驱动程序&lt;/li&gt;
&lt;li&gt;兼容性支持模块(CSM)&lt;/li&gt;
&lt;li&gt;EFI高层应用 - 硬件厂商开发的基于固件的高级应用&lt;/li&gt;
&lt;li&gt;GUID磁盘分区表&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;EFI负责加电自检(POST)、连系操作系统以及提供连接操作系统与硬件的接口。系统开机时，最先执行Pre-EFI初始化模块，负责CPU、主桥和存储器初始化。之后载入DXE，此时具有枚举并加载其他EFI驱动的能力。在PCI架构的系统中，各PCI桥及PCI适配器的EFI驱动先被加载并初始化，然后枚举并加载这些桥和适配器后面的各种总线和适配器。EFI驱动可放置在系统任何位置，只要可以按顺序枚举即可。部分EFI驱动也可放置在EFI系统分区中。CMS是x86平台EFI系统的一个特殊模块，为不具备EFI引导能力的操作系统提供类似传统BIOS的服务(UEFI Boot || Legacy Boot)。&lt;/p&gt;

&lt;p&gt;安全问题，虽然较BIOS危险，但也更容易恢复，如系统引导依赖的EFI驱动并不存放在EFI的GUID分区中，保证部分驱动损坏后依然可以通过引导Live CD启动等方式修复。另EFI引入Secure Boot概念，可在设置页面UEFI Boot选项下打开或关闭。其目的是防止恶意软件侵入，做法是采用密钥。主板出厂时内置一些可靠公钥，自己也可导入。任何要在此主板上加载的操作系统和驱动必须有对应私钥。不过此设置也存在争议，如Windows8认证机器只有&lt;a href=&quot;http://zh.wikipedia.org/wiki/OEM&quot; title=&quot;贴牌生产&quot;&gt;OEM&lt;/a&gt;和微软公钥且默认开启Secure Boot而限制通用的Linux开机，虽然关闭Secure Boot即可实现，但这样将使正版Windows无法使用。安装Windows的移动设备则不提供关闭Secure Boot的选项。这受到&lt;a href=&quot;http://www.fsf.org/campaigns/&quot; title=&quot;Free Software Foundation - Current campaigns&quot;&gt;自由软件基金会(FSF)&lt;/a&gt;的反对。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;EFI引入突破传MBR结构限制的GUID磁盘分区系统(GPT)。&lt;/em&gt;&lt;/p&gt;

&lt;h1&gt;参看&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/BIOS&quot; title=&quot;BIOS&quot;&gt;BIOS-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baike.baidu.com/view/361.htm&quot; title=&quot;bios&quot;&gt;BIOS-百度百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E5%8F%AF%E6%89%A9%E5%B1%95%E5%9B%BA%E4%BB%B6%E6%8E%A5%E5%8F%A3&quot; title=&quot;统一可扩展固件接口&quot;&gt;UEFI-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://os.51cto.com/art/200810/94530.htm&quot; title=&quot;Windows7将舍弃BIOS的奥秘：EFI接口详解&quot;&gt;Windows7将舍弃BIOS的奥秘：EFI接口详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://zh.wikipedia.org/wiki/ACPI&quot; title=&quot;高级配置与电源接口&quot;&gt;ACPI-维基百科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/01/secure_boot.html&quot; title=&quot;反Secure Boot垄断：兼谈如何在Windows 8电脑上安装Linux&quot;&gt;反Secure Boot垄断：兼谈如何在Windows 8电脑上安装Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2013/02/booting.html&quot; title=&quot;计算机是如何启动的？&quot;&gt;计算机是如何启动的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/l-linuxboot/&quot; title=&quot;Linux 引导过程内幕&quot;&gt;Linux 引导过程内幕&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
				<pubDate>Fri, 25 Apr 2014 00:00:00 +0800</pubDate>
				<link>http://zp.rensidiaochaotian.com//%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/2014/04/25/%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B%E5%92%8C%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E4%B8%80.html</link>
				<guid isPermaLink="true">http://zp.rensidiaochaotian.com//%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/2014/04/25/%E5%BC%80%E6%9C%BA%E8%BF%87%E7%A8%8B%E5%92%8C%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A%E4%B8%80.html</guid>
			</item>
		
	</channel>
</rss>